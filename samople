from flask import Flask,render_template,request,Response
app = Flask(__name__)
import cv2, numpy as np, glob
import os
camera = cv2.VideoCapture(0)
face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
eye_cascade = cv2.CascadeClassifier('haarcascade_eye.xml')
def gen_frames_watch():  #watch cam
    img1 = cv2.imread('pattern.jpg') #mianitem
    win_name = 'Camera Matching'
    MIN_MATCH = 10
    images = glob.glob('*.JPG')
    print(images)
    currentImage=0  
    replaceImg=cv2.imread(images[1])
    rows,cols,ch = replaceImg.shape
    pts1 = np.float32([[0, 0],[0,rows],[(cols),(rows)],[cols,0]])
    zoomLevel = 0   
    processing = True   
    maskThreshold=10

    detector = cv2.ORB_create(1000)

    FLANN_INDEX_LSH = 6
    index_params= dict(algorithm = FLANN_INDEX_LSH,
                    table_number = 6,
                    key_size = 12,
                    multi_probe_level = 1)
    search_params=dict(checks=32)
    matcher = cv2.FlannBasedMatcher(index_params, search_params)

    cap = cv2.VideoCapture(0)
  
    #---------
    while True:
      
        success, frame = cap.read()
        if img1 is None:
            res = frame
        else:
            img2 = frame
            gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
            gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)
            kp1, desc1 = detector.detectAndCompute(gray1, None)
            kp2, desc2 = detector.detectAndCompute(gray2, None)
            matches = matcher.knnMatch(desc1, desc2, 2)
            ratio = 0.75
            good_matches = [m[0] for m in matches \
                                if len(m) == 2 and m[0].distance < m[1].distance * ratio]
            matchesMask = np.zeros(len(good_matches)).tolist()
            if len(good_matches) > MIN_MATCH:
                src_pts = np.float32([ kp1[m.queryIdx].pt for m in good_matches ])
                dst_pts = np.float32([ kp2[m.trainIdx].pt for m in good_matches ])
                mtrx, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
   
                if mask.sum() > MIN_MATCH:
                    matchesMask = mask.ravel().tolist()
                    h,w, = img1.shape[:2]
                    pts = np.float32([ [[0,0]],[[0,h-1]],[[w-1,h-1]],[[w-1,0]] ])
                    dst = cv2.perspectiveTransform(pts,mtrx)
                    dst = cv2.getPerspectiveTransform(pts1,dst)
                    rows, cols, ch = frame.shape
                    distance = cv2.warpPerspective(replaceImg,dst,(cols,rows))
                    rt, mk = cv2.threshold(cv2.cvtColor(distance, cv2.COLOR_BGR2GRAY), maskThreshold, 1,cv2.THRESH_BINARY_INV)
                    mk = cv2.erode(mk, (3, 3))
                    mk = cv2.dilate(mk, (3, 3))
                    
                    for c in range(0, 3):
                        frame[:, :, c] = distance[:,:,c]*(1-mk[:,:]) + frame[:,:,c]*mk[:,:]
        if not success:
            break
        else:
            ret, buffer = cv2.imencode('.jpg', frame)
            frame = buffer.tobytes()
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')  
def gen_frames():  
    while True:
    
        success, frame = camera.read() 
        gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
        face_rects=face_cascade.detectMultiScale(gray,1.3,5)
        for (x,y,w,h) in face_rects:
            cv2.rectangle(frame,(x,y),(x+w,y+h),(0,255,0),2)
            roi_gray = gray[y:y+h,x:x+w]
            roi_color = frame[y:y+h, x:x+w]
            eyes = eye_cascade.detectMultiScale(roi_gray)
            for (ex,ey,ew,eh) in eyes:
                cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2)
            break

        if not success:
            break
        else:
            ret, buffer = cv2.imencode('.jpg', frame)
            frame = buffer.tobytes()
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')  

@app.route("/spectacles")
def index():
    return render_template("home.html")
@app.route("/watches")
def watches():
    return render_template("watches.html")

@app.route("/product", methods=['GET'])
def product():
    val = request.args['id']
    iden  = request.args['val']
    if(iden[0]=="2"):
        return render_template("product.html",prod=val,item="watch")
    else:
        return render_template("product.html",prod=val,item="watch2w")

@app.route('/video_feed')
def spec_video_feed():
    
    return Response(gen_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route("/watch_feed")
def watch_video_feed():
    return Response(gen_frames_watch(), mimetype='multipart/x-mixed-replace; boundary=frame')


if __name__ == "__main__":
    app.run(debug=True)